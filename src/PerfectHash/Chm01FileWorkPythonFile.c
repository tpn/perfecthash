/*++

Copyright (c) 2026 Trent Nelson <trent@trent.me>

Module Name:

    Chm01FileWorkPythonFile.c

Abstract:

    This module implements the save file work callback routine for the Python
    source file as part of the CHM v1 algorithm implementation for the perfect
    hash library.

--*/

#include "stdafx.h"

_Use_decl_annotations_
HRESULT
SavePythonFileChm01(
    PPERFECT_HASH_CONTEXT Context,
    PFILE_WORK_ITEM Item
    )
{
    PRTL Rtl;
    PCHAR Base;
    PCHAR Output;
    ULONG Count;
    PULONG Long;
    ULONGLONG Index;
    PCSTRING Name;
    PULONG Seeds;
    ULONG Seed1;
    ULONG Seed2;
    ULONG Seed3;
    ULONG Seed4;
    ULONG Seed5;
    ULONG Seed3Byte1;
    ULONG Seed3Byte2;
    ULONG Seed3Byte3;
    ULONG Seed3Byte4;
    PGRAPH Graph;
    PULONG Source;
    PUSHORT Source16;
    ULONGLONG NumberOfKeys;
    ULONG NumberOfSeeds;
    HRESULT Result = S_OK;
    PPERFECT_HASH_KEYS Keys;
    PPERFECT_HASH_PATH Path;
    PPERFECT_HASH_FILE File;
    PPERFECT_HASH_TABLE Table;
    PTABLE_INFO_ON_DISK TableInfo;
    ULONGLONG TotalNumberOfElements;
    const ULONG Indent = 0x20202020;
    BOOLEAN UsingAssigned16;
    BOOLEAN Supported;

    //
    // Initialize aliases.
    //

    Rtl = Context->Rtl;
    Table = Context->Table;
    Keys = Table->Keys;
    File = *Item->FilePointer;
    Path = GetActivePath(File);
    Name = &Path->TableNameA;
    TableInfo = Table->TableInfoOnDisk;
    TotalNumberOfElements = TableInfo->NumberOfTableElements.QuadPart;
    Graph = (PGRAPH)Context->SolvedContext;
    NumberOfSeeds = Graph->NumberOfSeeds;
    Seeds = &Graph->FirstSeed;
    NumberOfKeys = Keys->NumberOfKeys.QuadPart;
    UsingAssigned16 = IsUsingAssigned16(Graph);
    Supported = (
        Table->MaskFunctionId == PerfectHashAndMaskFunctionId &&
        IsGoodPerfectHashHashFunctionId(Table->HashFunctionId)
    );

    Base = (PCHAR)File->BaseAddress;
    Output = Base;

    //
    // Write header and metadata.
    //

    OUTPUT_RAW("# Auto-generated by Perfect Hash.\n");
    OUTPUT_RAW("# Table: ");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n\n");

    OUTPUT_RAW("TABLE_NAME = \"");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\"\n");
    OUTPUT_RAW("ALGORITHM_ID = ");
    OUTPUT_INT(Table->AlgorithmId);
    OUTPUT_RAW("\nHASH_FUNCTION_ID = ");
    OUTPUT_INT(Table->HashFunctionId);
    OUTPUT_RAW("\nMASK_FUNCTION_ID = ");
    OUTPUT_INT(Table->MaskFunctionId);
    OUTPUT_RAW("\n\n");

    OUTPUT_RAW("KEY_SIZE_BYTES = ");
    OUTPUT_INT(Keys->KeySizeInBytes);
    OUTPUT_RAW("\nORIGINAL_KEY_SIZE_BYTES = ");
    OUTPUT_INT(Keys->OriginalKeySizeInBytes);
    OUTPUT_RAW("\nNUMBER_OF_KEYS = ");
    OUTPUT_INT(NumberOfKeys);
    OUTPUT_RAW("\nNUMBER_OF_TABLE_ELEMENTS = ");
    OUTPUT_INT(TotalNumberOfElements);
    OUTPUT_RAW("\nHASH_MASK = ");
    OUTPUT_HEX(TableInfo->HashMask);
    OUTPUT_RAW("\nINDEX_MASK = ");
    OUTPUT_HEX(TableInfo->IndexMask);
    OUTPUT_RAW("\nDOWNSIZE_BITMAP = ");
    if (KeysWereDownsized(Keys)) {
        OUTPUT_HEX64(Keys->DownsizeBitmap);
    } else {
        OUTPUT_RAW("0");
    }
    OUTPUT_RAW("\nSUPPORTED = ");
    if (Supported) {
        OUTPUT_RAW("True");
    } else {
        OUTPUT_RAW("False");
    }
    OUTPUT_RAW("\n\n");

    //
    // Write seed data.
    //

    OUTPUT_RAW("SEEDS = [\n");

    for (Index = 0, Count = 0; Index < NumberOfSeeds; Index++) {

        if (Count == 0) {
            INDENT();
        }

        OUTPUT_HEX(*Seeds++);

        *Output++ = ',';

        if (++Count == 4) {
            Count = 0;
            *Output++ = '\n';
        } else {
            *Output++ = ' ';
        }
    }

    if (*(Output - 1) == ' ') {
        *(Output - 1) = '\n';
    }

    OUTPUT_RAW("]\n\n");

    Seed1 = (NumberOfSeeds >= 1 ? Graph->Seeds[0] : 0);
    Seed2 = (NumberOfSeeds >= 2 ? Graph->Seeds[1] : 0);
    Seed3 = (NumberOfSeeds >= 3 ? Graph->Seeds[2] : 0);
    Seed4 = (NumberOfSeeds >= 4 ? Graph->Seeds[3] : 0);
    Seed5 = (NumberOfSeeds >= 5 ? Graph->Seeds[4] : 0);
    Seed3Byte1 = (Seed3 & 0xff);
    Seed3Byte2 = ((Seed3 >> 8) & 0xff);
    Seed3Byte3 = ((Seed3 >> 16) & 0xff);
    Seed3Byte4 = ((Seed3 >> 24) & 0xff);

    OUTPUT_RAW("SEED1 = ");
    OUTPUT_HEX(Seed1);
    OUTPUT_RAW("\nSEED2 = ");
    OUTPUT_HEX(Seed2);
    OUTPUT_RAW("\nSEED3 = ");
    OUTPUT_HEX(Seed3);
    OUTPUT_RAW("\nSEED4 = ");
    OUTPUT_HEX(Seed4);
    OUTPUT_RAW("\nSEED5 = ");
    OUTPUT_HEX(Seed5);
    OUTPUT_RAW("\nSEED3_BYTE1 = ");
    OUTPUT_HEX(Seed3Byte1);
    OUTPUT_RAW("\nSEED3_BYTE2 = ");
    OUTPUT_HEX(Seed3Byte2);
    OUTPUT_RAW("\nSEED3_BYTE3 = ");
    OUTPUT_HEX(Seed3Byte3);
    OUTPUT_RAW("\nSEED3_BYTE4 = ");
    OUTPUT_HEX(Seed3Byte4);
    OUTPUT_RAW("\n\n");

    //
    // Write table data.
    //

    OUTPUT_RAW("TABLE_DATA = [\n");

    if (UsingAssigned16) {

        Source16 = Graph->Assigned16;

        for (Index = 0, Count = 0;
             Index < TotalNumberOfElements;
             Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX(*Source16++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }

    } else {

        Source = Graph->Assigned;

        for (Index = 0, Count = 0;
             Index < TotalNumberOfElements;
             Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX(*Source++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }
    }

    if (*(Output - 1) == ' ') {
        *(Output - 1) = '\n';
    }

    OUTPUT_RAW("]\n\n");

    //
    // Write keys.
    //

    OUTPUT_RAW("KEYS = [\n");

    if (Keys->OriginalKeySizeType == LongType) {

        PULONG SourceKeys;

        SourceKeys = (PULONG)Keys->KeyArrayBaseAddress;

        for (Index = 0, Count = 0; Index < NumberOfKeys; Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX(*SourceKeys++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }

    } else if (Keys->OriginalKeySizeType == LongLongType) {

        PULONGLONG SourceKeys;

        SourceKeys = (PULONGLONG)Keys->File->BaseAddress;

        for (Index = 0, Count = 0; Index < NumberOfKeys; Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX64(*SourceKeys++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }

    } else {

        Result = PH_E_UNREACHABLE_CODE;
        PH_ERROR(SavePythonFileChm01_UnknownKeyType, Result);
        PH_RAISE(Result);
    }

    if (*(Output - 1) == ' ') {
        *(Output - 1) = '\n';
    }

    OUTPUT_RAW("]\n\n");

    //
    // Write helpers and index routine.
    //

    OUTPUT_RAW("KEY_MASK = (1 << (KEY_SIZE_BYTES * 8)) - 1\n");
    OUTPUT_RAW("KEY_TYPE_MASK = ");
    if (Keys->KeySizeInBytes <= 4) {
        OUTPUT_RAW("0xFFFFFFFF\n");
    } else {
        OUTPUT_RAW("0xFFFFFFFFFFFFFFFF\n");
    }
    OUTPUT_RAW("ORIGINAL_KEY_MASK = (1 << (ORIGINAL_KEY_SIZE_BYTES * 8)) - 1\n\n");

    OUTPUT_RAW("def _extract_bits64(value, bitmap):\n");
    OUTPUT_RAW("    result = 0\n");
    OUTPUT_RAW("    out_bit = 0\n");
    OUTPUT_RAW("    while bitmap:\n");
    OUTPUT_RAW("        lsb = bitmap & -bitmap\n");
    OUTPUT_RAW("        if value & lsb:\n");
    OUTPUT_RAW("            result |= 1 << out_bit\n");
    OUTPUT_RAW("        bitmap ^= lsb\n");
    OUTPUT_RAW("        out_bit += 1\n");
    OUTPUT_RAW("    return result\n\n");

    OUTPUT_RAW("def _downsize_key(key):\n");
    OUTPUT_RAW("    key &= ORIGINAL_KEY_MASK\n");
    OUTPUT_RAW("    if DOWNSIZE_BITMAP:\n");
    OUTPUT_RAW("        return _extract_bits64(key, DOWNSIZE_BITMAP) & KEY_MASK\n");
    OUTPUT_RAW("    return key & KEY_MASK\n\n");

    OUTPUT_RAW("def _rotr32(value, shift):\n");
    OUTPUT_RAW("    shift &= 31\n");
    OUTPUT_RAW("    if shift == 0:\n");
    OUTPUT_RAW("        return value & 0xFFFFFFFF\n");
    OUTPUT_RAW("    return ((value >> shift) | ");
    OUTPUT_RAW("((value << (32 - shift)) & 0xFFFFFFFF)) & 0xFFFFFFFF\n\n");

    if (Table->MaskFunctionId == PerfectHashAndMaskFunctionId) {

        if (Table->HashFunctionId ==
            PerfectHashHashMultiplyShiftRFunctionId) {

            OUTPUT_RAW("def index(key):\n");
            OUTPUT_RAW("    key = _downsize_key(key)\n");
            OUTPUT_RAW("    vertex1 = (key * SEED1) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1\n");
            OUTPUT_RAW("    vertex2 = (key * SEED2) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex2 >>= SEED3_BYTE2\n");
            OUTPUT_RAW("    masked_low = vertex1 & HASH_MASK\n");
            OUTPUT_RAW("    masked_high = vertex2 & HASH_MASK\n");
            OUTPUT_RAW("    return (TABLE_DATA[masked_low] + ");
            OUTPUT_RAW("TABLE_DATA[masked_high]) & INDEX_MASK\n");

        } else if (Table->HashFunctionId ==
                   PerfectHashHashMultiplyShiftLRFunctionId) {

            OUTPUT_RAW("def index(key):\n");
            OUTPUT_RAW("    key = _downsize_key(key)\n");
            OUTPUT_RAW("    vertex1 = (key * SEED1) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex1 = (vertex1 << SEED3_BYTE1) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex2 = (key * SEED2) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex2 >>= SEED3_BYTE2\n");
            OUTPUT_RAW("    masked_low = vertex1 & HASH_MASK\n");
            OUTPUT_RAW("    masked_high = vertex2 & HASH_MASK\n");
            OUTPUT_RAW("    return (TABLE_DATA[masked_low] + ");
            OUTPUT_RAW("TABLE_DATA[masked_high]) & INDEX_MASK\n");

        } else if (Table->HashFunctionId ==
                   PerfectHashHashMultiplyShiftRMultiplyFunctionId) {

            OUTPUT_RAW("def index(key):\n");
            OUTPUT_RAW("    key = _downsize_key(key)\n");
            OUTPUT_RAW("    vertex1 = (key * SEED1) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1\n");
            OUTPUT_RAW("    vertex1 = (vertex1 * SEED2) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex2 = (key * SEED4) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex2 >>= SEED3_BYTE2\n");
            OUTPUT_RAW("    vertex2 = (vertex2 * SEED5) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    masked_low = vertex1 & HASH_MASK\n");
            OUTPUT_RAW("    masked_high = vertex2 & HASH_MASK\n");
            OUTPUT_RAW("    return (TABLE_DATA[masked_low] + ");
            OUTPUT_RAW("TABLE_DATA[masked_high]) & INDEX_MASK\n");

        } else if (Table->HashFunctionId ==
                   PerfectHashHashMultiplyShiftR2FunctionId) {

            OUTPUT_RAW("def index(key):\n");
            OUTPUT_RAW("    key = _downsize_key(key)\n");
            OUTPUT_RAW("    vertex1 = (key * SEED1) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1\n");
            OUTPUT_RAW("    vertex1 = (vertex1 * SEED2) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex1 >>= SEED3_BYTE2\n");
            OUTPUT_RAW("    vertex2 = (key * SEED4) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex2 >>= SEED3_BYTE3\n");
            OUTPUT_RAW("    vertex2 = (vertex2 * SEED5) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex2 >>= SEED3_BYTE4\n");
            OUTPUT_RAW("    masked_low = vertex1 & HASH_MASK\n");
            OUTPUT_RAW("    masked_high = vertex2 & HASH_MASK\n");
            OUTPUT_RAW("    return (TABLE_DATA[masked_low] + ");
            OUTPUT_RAW("TABLE_DATA[masked_high]) & INDEX_MASK\n");

        } else if (Table->HashFunctionId ==
                   PerfectHashHashMultiplyShiftRXFunctionId) {

            OUTPUT_RAW("def index(key):\n");
            OUTPUT_RAW("    key = _downsize_key(key)\n");
            OUTPUT_RAW("    vertex1 = (key * SEED1) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1\n");
            OUTPUT_RAW("    vertex2 = (key * SEED2) & KEY_TYPE_MASK\n");
            OUTPUT_RAW("    vertex2 >>= SEED3_BYTE1\n");
            OUTPUT_RAW("    return (TABLE_DATA[vertex1] + ");
            OUTPUT_RAW("TABLE_DATA[vertex2]) & INDEX_MASK\n");

        } else if (Table->HashFunctionId ==
                   PerfectHashHashMulshrolate1RXFunctionId) {

            OUTPUT_RAW("def index(key):\n");
            OUTPUT_RAW("    key = _downsize_key(key)\n");
            OUTPUT_RAW("    vertex1 = (key * SEED1) & 0xFFFFFFFF\n");
            OUTPUT_RAW("    vertex1 = _rotr32(vertex1, SEED3_BYTE2)\n");
            OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1\n");
            OUTPUT_RAW("    vertex2 = (key * SEED2) & 0xFFFFFFFF\n");
            OUTPUT_RAW("    vertex2 >>= SEED3_BYTE1\n");
            OUTPUT_RAW("    return (TABLE_DATA[vertex1] + ");
            OUTPUT_RAW("TABLE_DATA[vertex2]) & INDEX_MASK\n");

        } else if (Table->HashFunctionId ==
                   PerfectHashHashMulshrolate2RXFunctionId) {

            OUTPUT_RAW("def index(key):\n");
            OUTPUT_RAW("    key = _downsize_key(key)\n");
            OUTPUT_RAW("    vertex1 = (key * SEED1) & 0xFFFFFFFF\n");
            OUTPUT_RAW("    vertex1 = _rotr32(vertex1, SEED3_BYTE2)\n");
            OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1\n");
            OUTPUT_RAW("    vertex2 = (key * SEED2) & 0xFFFFFFFF\n");
            OUTPUT_RAW("    vertex2 = _rotr32(vertex2, SEED3_BYTE3)\n");
            OUTPUT_RAW("    vertex2 >>= SEED3_BYTE1\n");
            OUTPUT_RAW("    return (TABLE_DATA[vertex1] + ");
            OUTPUT_RAW("TABLE_DATA[vertex2]) & INDEX_MASK\n");

        } else if (Table->HashFunctionId ==
                   PerfectHashHashMulshrolate3RXFunctionId) {

            OUTPUT_RAW("def index(key):\n");
            OUTPUT_RAW("    key = _downsize_key(key)\n");
            OUTPUT_RAW("    vertex1 = (key * SEED1) & 0xFFFFFFFF\n");
            OUTPUT_RAW("    vertex1 = _rotr32(vertex1, SEED3_BYTE2)\n");
            OUTPUT_RAW("    vertex1 = (vertex1 * SEED4) & 0xFFFFFFFF\n");
            OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1\n");
            OUTPUT_RAW("    vertex2 = (key * SEED2) & 0xFFFFFFFF\n");
            OUTPUT_RAW("    vertex2 = _rotr32(vertex2, SEED3_BYTE3)\n");
            OUTPUT_RAW("    vertex2 >>= SEED3_BYTE1\n");
            OUTPUT_RAW("    return (TABLE_DATA[vertex1] + ");
            OUTPUT_RAW("TABLE_DATA[vertex2]) & INDEX_MASK\n");

        } else if (Table->HashFunctionId ==
                   PerfectHashHashMulshrolate4RXFunctionId) {

            OUTPUT_RAW("def index(key):\n");
            OUTPUT_RAW("    key = _downsize_key(key)\n");
            OUTPUT_RAW("    vertex1 = (key * SEED1) & 0xFFFFFFFF\n");
            OUTPUT_RAW("    vertex1 = _rotr32(vertex1, SEED3_BYTE2)\n");
            OUTPUT_RAW("    vertex1 = (vertex1 * SEED4) & 0xFFFFFFFF\n");
            OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1\n");
            OUTPUT_RAW("    vertex2 = (key * SEED2) & 0xFFFFFFFF\n");
            OUTPUT_RAW("    vertex2 = _rotr32(vertex2, SEED3_BYTE3)\n");
            OUTPUT_RAW("    vertex2 = (vertex2 * SEED5) & 0xFFFFFFFF\n");
            OUTPUT_RAW("    vertex2 >>= SEED3_BYTE1\n");
            OUTPUT_RAW("    return (TABLE_DATA[vertex1] + ");
            OUTPUT_RAW("TABLE_DATA[vertex2]) & INDEX_MASK\n");

        } else {

            OUTPUT_RAW("def index(key):\n");
            OUTPUT_RAW("    raise NotImplementedError(\n");
            OUTPUT_RAW("        \"Unsupported hash/mask combination for Python\")\n");
        }

    } else {

        OUTPUT_RAW("def index(key):\n");
        OUTPUT_RAW("    raise NotImplementedError(\n");
        OUTPUT_RAW("        \"Unsupported hash/mask combination for Python\")\n");
    }

    //
    // Update the number of bytes written.
    //

    File->NumberOfBytesWritten.QuadPart = RtlPointerToOffset(Base, Output);

    return Result;
}

// vim:set ts=8 sw=4 sts=4 tw=80 expandtab                                     :