/*++

Copyright (c) 2026 Trent Nelson <trent@trent.me>

Module Name:

    Chm01FileWorkRustLibFile.c

Abstract:

    This module implements the save file work callback routine for the Rust
    library file as part of the CHM v1 algorithm implementation for the
    perfect hash library.

--*/

#include "stdafx.h"

_Use_decl_annotations_
HRESULT
SaveRustLibFileChm01(
    PPERFECT_HASH_CONTEXT Context,
    PFILE_WORK_ITEM Item
    )
{
    PRTL Rtl;
    PCHAR Base;
    PCHAR Output;
    ULONG Count;
    PULONG Long;
    ULONGLONG Index;
    PCSTRING Name;
    PULONG Seeds;
    ULONG Seed1;
    ULONG Seed2;
    ULONG Seed3;
    ULONG Seed4;
    ULONG Seed5;
    ULONG Seed3Byte1;
    ULONG Seed3Byte2;
    ULONG Seed3Byte3;
    ULONG Seed3Byte4;
    PGRAPH Graph;
    PULONG Source;
    PUSHORT Source16;
    ULONGLONG NumberOfKeys;
    ULONG NumberOfSeeds;
    BOOLEAN UsingAssigned16;
    BOOLEAN Supported;
    HRESULT Result = S_OK;
    PPERFECT_HASH_KEYS Keys;
    PPERFECT_HASH_PATH Path;
    PPERFECT_HASH_FILE File;
    PPERFECT_HASH_TABLE Table;
    PTABLE_INFO_ON_DISK TableInfo;
    ULONGLONG TotalNumberOfElements;
    const ULONG Indent = 0x20202020;

    //
    // Initialize aliases.
    //

    Rtl = Context->Rtl;
    Table = Context->Table;
    Keys = Table->Keys;
    File = *Item->FilePointer;
    Path = GetActivePath(File);
    Name = &Path->TableNameA;
    TableInfo = Table->TableInfoOnDisk;
    TotalNumberOfElements = TableInfo->NumberOfTableElements.QuadPart;
    Graph = (PGRAPH)Context->SolvedContext;
    NumberOfSeeds = Graph->NumberOfSeeds;
    Seeds = &Graph->FirstSeed;
    NumberOfKeys = Keys->NumberOfKeys.QuadPart;
    UsingAssigned16 = IsUsingAssigned16(Graph);
    Supported = (
        Table->MaskFunctionId == PerfectHashAndMaskFunctionId &&
        IsGoodPerfectHashHashFunctionId(Table->HashFunctionId)
    );

    Base = (PCHAR)File->BaseAddress;
    Output = Base;

    //
    // Write header and metadata.
    //

    OUTPUT_RAW("// Auto-generated by Perfect Hash.\n");
    OUTPUT_RAW("// Table: ");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n\n");

    OUTPUT_RAW("pub const TABLE_NAME: &str = \"");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\";\n");
    OUTPUT_RAW("pub const ALGORITHM_ID: u32 = ");
    OUTPUT_INT(Table->AlgorithmId);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const HASH_FUNCTION_ID: u32 = ");
    OUTPUT_INT(Table->HashFunctionId);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const MASK_FUNCTION_ID: u32 = ");
    OUTPUT_INT(Table->MaskFunctionId);
    OUTPUT_RAW(";\n\n");

    OUTPUT_RAW("pub const KEY_SIZE_BYTES: u32 = ");
    OUTPUT_INT(Keys->KeySizeInBytes);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const ORIGINAL_KEY_SIZE_BYTES: u32 = ");
    OUTPUT_INT(Keys->OriginalKeySizeInBytes);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const NUMBER_OF_KEYS: usize = ");
    OUTPUT_INT(NumberOfKeys);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const NUMBER_OF_TABLE_ELEMENTS: usize = ");
    OUTPUT_INT(TotalNumberOfElements);
    OUTPUT_RAW(";\n\n");

    OUTPUT_RAW("pub const HASH_MASK: u32 = ");
    OUTPUT_HEX(TableInfo->HashMask);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const INDEX_MASK: u32 = ");
    OUTPUT_HEX(TableInfo->IndexMask);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const DOWNSIZE_BITMAP: u64 = ");
    if (KeysWereDownsized(Keys)) {
        OUTPUT_HEX64(Keys->DownsizeBitmap);
    } else {
        OUTPUT_RAW("0");
    }
    OUTPUT_RAW(";\n\n");

    if (Keys->KeySizeInBytes <= 4) {
        OUTPUT_RAW("pub type KeyType = u32;\n");
    } else {
        OUTPUT_RAW("pub type KeyType = u64;\n");
    }

    if (Keys->OriginalKeySizeInBytes <= 4) {
        OUTPUT_RAW("pub type OriginalKeyType = u32;\n");
    } else {
        OUTPUT_RAW("pub type OriginalKeyType = u64;\n");
    }

    if (UsingAssigned16) {
        OUTPUT_RAW("pub type TableDataType = u16;\n\n");
    } else {
        OUTPUT_RAW("pub type TableDataType = u32;\n\n");
    }

    OUTPUT_RAW("pub const KEY_BITS: u32 = KEY_SIZE_BYTES * 8;\n");
    OUTPUT_RAW("pub const ORIGINAL_KEY_BITS: u32 = "
               "ORIGINAL_KEY_SIZE_BYTES * 8;\n");
    OUTPUT_RAW("const fn mask_from_bits(bits: u32) -> u64 {\n");
    OUTPUT_RAW("    if bits >= 64 { u64::MAX } else { (1u64 << bits) - 1 }\n");
    OUTPUT_RAW("}\n");
    OUTPUT_RAW("pub const KEY_MASK: u64 = mask_from_bits(KEY_BITS);\n");
    OUTPUT_RAW("pub const ORIGINAL_KEY_MASK: u64 = "
               "mask_from_bits(ORIGINAL_KEY_BITS);\n\n");

    OUTPUT_RAW("pub const SUPPORTED: bool = ");
    if (Supported) {
        OUTPUT_RAW("true");
    } else {
        OUTPUT_RAW("false");
    }
    OUTPUT_RAW(";\n\n");

    //
    // Write seed data.
    //

    OUTPUT_RAW("pub const NUMBER_OF_SEEDS: usize = ");
    OUTPUT_INT(NumberOfSeeds);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const SEEDS: [u32; NUMBER_OF_SEEDS] = [\n");

    for (Index = 0, Count = 0; Index < NumberOfSeeds; Index++) {

        if (Count == 0) {
            INDENT();
        }

        OUTPUT_HEX(*Seeds++);

        *Output++ = ',';

        if (++Count == 4) {
            Count = 0;
            *Output++ = '\n';
        } else {
            *Output++ = ' ';
        }
    }

    if (*(Output - 1) == ' ') {
        *(Output - 1) = '\n';
    }

    OUTPUT_RAW("];\n\n");

    Seed1 = (NumberOfSeeds >= 1 ? Graph->Seeds[0] : 0);
    Seed2 = (NumberOfSeeds >= 2 ? Graph->Seeds[1] : 0);
    Seed3 = (NumberOfSeeds >= 3 ? Graph->Seeds[2] : 0);
    Seed4 = (NumberOfSeeds >= 4 ? Graph->Seeds[3] : 0);
    Seed5 = (NumberOfSeeds >= 5 ? Graph->Seeds[4] : 0);
    Seed3Byte1 = (Seed3 & 0xff);
    Seed3Byte2 = ((Seed3 >> 8) & 0xff);
    Seed3Byte3 = ((Seed3 >> 16) & 0xff);
    Seed3Byte4 = ((Seed3 >> 24) & 0xff);

    OUTPUT_RAW("pub const SEED1: u32 = ");
    OUTPUT_HEX(Seed1);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const SEED2: u32 = ");
    OUTPUT_HEX(Seed2);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const SEED3: u32 = ");
    OUTPUT_HEX(Seed3);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const SEED4: u32 = ");
    OUTPUT_HEX(Seed4);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const SEED5: u32 = ");
    OUTPUT_HEX(Seed5);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const SEED3_BYTE1: u32 = ");
    OUTPUT_HEX(Seed3Byte1);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const SEED3_BYTE2: u32 = ");
    OUTPUT_HEX(Seed3Byte2);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const SEED3_BYTE3: u32 = ");
    OUTPUT_HEX(Seed3Byte3);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("pub const SEED3_BYTE4: u32 = ");
    OUTPUT_HEX(Seed3Byte4);
    OUTPUT_RAW(";\n\n");

    //
    // Write table data.
    //

    OUTPUT_RAW("pub const TABLE_DATA: [TableDataType; "
               "NUMBER_OF_TABLE_ELEMENTS] = [\n");

    if (UsingAssigned16) {
        Source16 = Graph->Assigned16;

        for (Index = 0, Count = 0;
             Index < TotalNumberOfElements;
             Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX(*Source16++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }

    } else {
        Source = Graph->Assigned;

        for (Index = 0, Count = 0;
             Index < TotalNumberOfElements;
             Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX(*Source++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }
    }

    if (*(Output - 1) == ' ') {
        *(Output - 1) = '\n';
    }

    OUTPUT_RAW("];\n\n");

    //
    // Write the keys array.
    //

    OUTPUT_RAW("pub const KEYS: [OriginalKeyType; NUMBER_OF_KEYS] = [\n");

    if (Keys->OriginalKeySizeType == LongType) {

        PULONG SourceKeys;

        SourceKeys = (PULONG)Keys->KeyArrayBaseAddress;

        for (Index = 0, Count = 0; Index < NumberOfKeys; Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX(*SourceKeys++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }

    } else if (Keys->OriginalKeySizeType == LongLongType) {

        PULONGLONG SourceKeys;

        SourceKeys = (PULONGLONG)Keys->File->BaseAddress;

        for (Index = 0, Count = 0; Index < NumberOfKeys; Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX64(*SourceKeys++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }

    } else {

        Result = PH_E_UNREACHABLE_CODE;
        PH_ERROR(SaveRustLibFileChm01_UnknownKeyType, Result);
        PH_RAISE(Result);
    }

    if (*(Output - 1) == ' ') {
        *(Output - 1) = '\n';
    }

    OUTPUT_RAW("];\n\n");

    //
    // Write helpers and index routine.
    //

    OUTPUT_RAW("fn extract_bits64(value: u64, bitmap: u64) -> u64 {\n");
    OUTPUT_RAW("    let mut result = 0u64;\n");
    OUTPUT_RAW("    let mut out_bit = 0u32;\n");
    OUTPUT_RAW("    let mut mask = bitmap;\n");
    OUTPUT_RAW("    while mask != 0 {\n");
    OUTPUT_RAW("        let lsb = mask & mask.wrapping_neg();\n");
    OUTPUT_RAW("        if (value & lsb) != 0 {\n");
    OUTPUT_RAW("            result |= 1u64 << out_bit;\n");
    OUTPUT_RAW("        }\n");
    OUTPUT_RAW("        mask ^= lsb;\n");
    OUTPUT_RAW("        out_bit += 1;\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    result\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("fn downsize_key(key: u64) -> KeyType {\n");
    OUTPUT_RAW("    let key = key & ORIGINAL_KEY_MASK;\n");
    OUTPUT_RAW("    if DOWNSIZE_BITMAP != 0 {\n");
    OUTPUT_RAW("        return (extract_bits64(key, DOWNSIZE_BITMAP) & KEY_MASK) "
               "as KeyType;\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    (key & KEY_MASK) as KeyType\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("fn rotr32(value: u32, shift: u32) -> u32 {\n");
    OUTPUT_RAW("    value.rotate_right(shift & 31)\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("pub fn index(key: OriginalKeyType) -> u32 {\n");
    OUTPUT_RAW("    if !SUPPORTED {\n");
    OUTPUT_RAW("        panic!(\"Unsupported hash/mask combination\");\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    let downsized = downsize_key(key as u64);\n");
    if (Table->HashFunctionId == PerfectHashHashMultiplyShiftRFunctionId) {
        OUTPUT_RAW("    let mut vertex1: KeyType = "
                   "downsized.wrapping_mul(SEED1 as KeyType);\n");
        OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1;\n");
        OUTPUT_RAW("    let mut vertex2: KeyType = "
                   "downsized.wrapping_mul(SEED2 as KeyType);\n");
        OUTPUT_RAW("    vertex2 >>= SEED3_BYTE2;\n");
        OUTPUT_RAW("    let masked_low = (vertex1 as u32) & HASH_MASK;\n");
        OUTPUT_RAW("    let masked_high = (vertex2 as u32) & HASH_MASK;\n");
        OUTPUT_RAW("    let value_low = "
                   "TABLE_DATA[masked_low as usize] as u32;\n");
        OUTPUT_RAW("    let value_high = "
                   "TABLE_DATA[masked_high as usize] as u32;\n");
        OUTPUT_RAW("    value_low.wrapping_add(value_high) & INDEX_MASK\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMultiplyShiftLRFunctionId) {
        OUTPUT_RAW("    let mut vertex1: KeyType = "
                   "downsized.wrapping_mul(SEED1 as KeyType);\n");
        OUTPUT_RAW("    vertex1 <<= SEED3_BYTE1;\n");
        OUTPUT_RAW("    let mut vertex2: KeyType = "
                   "downsized.wrapping_mul(SEED2 as KeyType);\n");
        OUTPUT_RAW("    vertex2 >>= SEED3_BYTE2;\n");
        OUTPUT_RAW("    let masked_low = (vertex1 as u32) & HASH_MASK;\n");
        OUTPUT_RAW("    let masked_high = (vertex2 as u32) & HASH_MASK;\n");
        OUTPUT_RAW("    let value_low = "
                   "TABLE_DATA[masked_low as usize] as u32;\n");
        OUTPUT_RAW("    let value_high = "
                   "TABLE_DATA[masked_high as usize] as u32;\n");
        OUTPUT_RAW("    value_low.wrapping_add(value_high) & INDEX_MASK\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMultiplyShiftRMultiplyFunctionId) {
        OUTPUT_RAW("    let mut vertex1: KeyType = "
                   "downsized.wrapping_mul(SEED1 as KeyType);\n");
        OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1;\n");
        OUTPUT_RAW("    vertex1 = vertex1.wrapping_mul(SEED2 as KeyType);\n");
        OUTPUT_RAW("    let mut vertex2: KeyType = "
                   "downsized.wrapping_mul(SEED4 as KeyType);\n");
        OUTPUT_RAW("    vertex2 >>= SEED3_BYTE2;\n");
        OUTPUT_RAW("    vertex2 = vertex2.wrapping_mul(SEED5 as KeyType);\n");
        OUTPUT_RAW("    let masked_low = (vertex1 as u32) & HASH_MASK;\n");
        OUTPUT_RAW("    let masked_high = (vertex2 as u32) & HASH_MASK;\n");
        OUTPUT_RAW("    let value_low = "
                   "TABLE_DATA[masked_low as usize] as u32;\n");
        OUTPUT_RAW("    let value_high = "
                   "TABLE_DATA[masked_high as usize] as u32;\n");
        OUTPUT_RAW("    value_low.wrapping_add(value_high) & INDEX_MASK\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMultiplyShiftR2FunctionId) {
        OUTPUT_RAW("    let mut vertex1: KeyType = "
                   "downsized.wrapping_mul(SEED1 as KeyType);\n");
        OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1;\n");
        OUTPUT_RAW("    vertex1 = vertex1.wrapping_mul(SEED2 as KeyType);\n");
        OUTPUT_RAW("    vertex1 >>= SEED3_BYTE2;\n");
        OUTPUT_RAW("    let mut vertex2: KeyType = "
                   "downsized.wrapping_mul(SEED4 as KeyType);\n");
        OUTPUT_RAW("    vertex2 >>= SEED3_BYTE3;\n");
        OUTPUT_RAW("    vertex2 = vertex2.wrapping_mul(SEED5 as KeyType);\n");
        OUTPUT_RAW("    vertex2 >>= SEED3_BYTE4;\n");
        OUTPUT_RAW("    let masked_low = (vertex1 as u32) & HASH_MASK;\n");
        OUTPUT_RAW("    let masked_high = (vertex2 as u32) & HASH_MASK;\n");
        OUTPUT_RAW("    let value_low = "
                   "TABLE_DATA[masked_low as usize] as u32;\n");
        OUTPUT_RAW("    let value_high = "
                   "TABLE_DATA[masked_high as usize] as u32;\n");
        OUTPUT_RAW("    value_low.wrapping_add(value_high) & INDEX_MASK\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMultiplyShiftRXFunctionId) {
        OUTPUT_RAW("    let mut vertex1: KeyType = "
                   "downsized.wrapping_mul(SEED1 as KeyType);\n");
        OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1;\n");
        OUTPUT_RAW("    let value_low = "
                   "TABLE_DATA[vertex1 as usize] as u32;\n");
        OUTPUT_RAW("    let mut vertex2: KeyType = "
                   "downsized.wrapping_mul(SEED2 as KeyType);\n");
        OUTPUT_RAW("    vertex2 >>= SEED3_BYTE1;\n");
        OUTPUT_RAW("    let value_high = "
                   "TABLE_DATA[vertex2 as usize] as u32;\n");
        OUTPUT_RAW("    value_low.wrapping_add(value_high) & INDEX_MASK\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMulshrolate1RXFunctionId) {
        OUTPUT_RAW("    let downsized32 = downsized as u32;\n");
        OUTPUT_RAW("    let mut vertex1 = downsized32.wrapping_mul(SEED1);\n");
        OUTPUT_RAW("    vertex1 = rotr32(vertex1, SEED3_BYTE2);\n");
        OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1;\n");
        OUTPUT_RAW("    let value_low = TABLE_DATA[vertex1 as usize] as u32;\n");
        OUTPUT_RAW("    let mut vertex2 = downsized32.wrapping_mul(SEED2);\n");
        OUTPUT_RAW("    vertex2 >>= SEED3_BYTE1;\n");
        OUTPUT_RAW("    let value_high = TABLE_DATA[vertex2 as usize] as u32;\n");
        OUTPUT_RAW("    value_low.wrapping_add(value_high) & INDEX_MASK\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMulshrolate2RXFunctionId) {
        OUTPUT_RAW("    let downsized32 = downsized as u32;\n");
        OUTPUT_RAW("    let mut vertex1 = downsized32.wrapping_mul(SEED1);\n");
        OUTPUT_RAW("    vertex1 = rotr32(vertex1, SEED3_BYTE2);\n");
        OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1;\n");
        OUTPUT_RAW("    let value_low = TABLE_DATA[vertex1 as usize] as u32;\n");
        OUTPUT_RAW("    let mut vertex2 = downsized32.wrapping_mul(SEED2);\n");
        OUTPUT_RAW("    vertex2 = rotr32(vertex2, SEED3_BYTE3);\n");
        OUTPUT_RAW("    vertex2 >>= SEED3_BYTE1;\n");
        OUTPUT_RAW("    let value_high = TABLE_DATA[vertex2 as usize] as u32;\n");
        OUTPUT_RAW("    value_low.wrapping_add(value_high) & INDEX_MASK\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMulshrolate3RXFunctionId) {
        OUTPUT_RAW("    let downsized32 = downsized as u32;\n");
        OUTPUT_RAW("    let mut vertex1 = downsized32.wrapping_mul(SEED1);\n");
        OUTPUT_RAW("    vertex1 = rotr32(vertex1, SEED3_BYTE2);\n");
        OUTPUT_RAW("    vertex1 = vertex1.wrapping_mul(SEED4);\n");
        OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1;\n");
        OUTPUT_RAW("    let value_low = TABLE_DATA[vertex1 as usize] as u32;\n");
        OUTPUT_RAW("    let mut vertex2 = downsized32.wrapping_mul(SEED2);\n");
        OUTPUT_RAW("    vertex2 = rotr32(vertex2, SEED3_BYTE3);\n");
        OUTPUT_RAW("    vertex2 >>= SEED3_BYTE1;\n");
        OUTPUT_RAW("    let value_high = TABLE_DATA[vertex2 as usize] as u32;\n");
        OUTPUT_RAW("    value_low.wrapping_add(value_high) & INDEX_MASK\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMulshrolate4RXFunctionId) {
        OUTPUT_RAW("    let downsized32 = downsized as u32;\n");
        OUTPUT_RAW("    let mut vertex1 = downsized32.wrapping_mul(SEED1);\n");
        OUTPUT_RAW("    vertex1 = rotr32(vertex1, SEED3_BYTE2);\n");
        OUTPUT_RAW("    vertex1 = vertex1.wrapping_mul(SEED4);\n");
        OUTPUT_RAW("    vertex1 >>= SEED3_BYTE1;\n");
        OUTPUT_RAW("    let value_low = TABLE_DATA[vertex1 as usize] as u32;\n");
        OUTPUT_RAW("    let mut vertex2 = downsized32.wrapping_mul(SEED2);\n");
        OUTPUT_RAW("    vertex2 = rotr32(vertex2, SEED3_BYTE3);\n");
        OUTPUT_RAW("    vertex2 = vertex2.wrapping_mul(SEED5);\n");
        OUTPUT_RAW("    vertex2 >>= SEED3_BYTE1;\n");
        OUTPUT_RAW("    let value_high = TABLE_DATA[vertex2 as usize] as u32;\n");
        OUTPUT_RAW("    value_low.wrapping_add(value_high) & INDEX_MASK\n");
    } else {
        OUTPUT_RAW("    let _ = downsized;\n");
        OUTPUT_RAW("    panic!(\"Unsupported hash/mask combination\");\n");
    }
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("#[cfg(test)]\n");
    OUTPUT_RAW("mod tests {\n");
    OUTPUT_RAW("    use super::*;\n\n");
    OUTPUT_RAW("    #[test]\n");
    OUTPUT_RAW("    fn indexes_are_unique() {\n");
    OUTPUT_RAW("        if !SUPPORTED {\n");
    OUTPUT_RAW("            return;\n");
    OUTPUT_RAW("        }\n");
    OUTPUT_RAW("        let mut seen = vec![0u8; INDEX_MASK as usize + 1];\n");
    OUTPUT_RAW("        let mut count = 0usize;\n");
    OUTPUT_RAW("        for &key in KEYS.iter() {\n");
    OUTPUT_RAW("            let idx = index(key);\n");
    OUTPUT_RAW("            let pos = idx as usize;\n");
    OUTPUT_RAW("            assert!(pos < seen.len(), \"index out of range: {}\", idx);\n");
    OUTPUT_RAW("            assert_eq!(seen[pos], 0, \"collision at {}\", idx);\n");
    OUTPUT_RAW("            seen[pos] = 1;\n");
    OUTPUT_RAW("            count += 1;\n");
    OUTPUT_RAW("        }\n");
    OUTPUT_RAW("        assert_eq!(count, NUMBER_OF_KEYS);\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("}\n");

    //
    // Update the number of bytes written.
    //

    File->NumberOfBytesWritten.QuadPart = RtlPointerToOffset(Base, Output);

    return Result;
}

// vim:set ts=8 sw=4 sts=4 tw=80 expandtab                                     :