/*++

Copyright (c) 2023-2026 Trent Nelson <trent@trent.me>

Module Name:

    Chm01FileWorkCMakeListsTextFile.c

Abstract:

    This module implements the prepare file work callback routine for the
    CMakeLists.txt file as part of the CHM v1 algorithm implementation for
    the perfect hash library.

--*/

#include "stdafx.h"
#include "CMakeLists_Text_RawCString.h"

_Use_decl_annotations_
HRESULT
PrepareCMakeListsTextFileChm01(
    PPERFECT_HASH_CONTEXT Context,
    PFILE_WORK_ITEM Item
    )
{
    PRTL Rtl;
    PCHAR Base;
    PCHAR Output;
    ULONG NumberOfSeeds;
    PCSTRING Name;
    PCSTRING Upper;
    BOOLEAN IncludeKeys;
    PPERFECT_HASH_KEYS Keys;
    PPERFECT_HASH_PATH Path;
    PPERFECT_HASH_FILE File;
    PPERFECT_HASH_DIRECTORY ParentDirectory;
    PPERFECT_HASH_TABLE Table;
    PTABLE_INFO_ON_DISK TableInfoOnDisk;

    //
    // Initialize aliases.
    //

    Rtl = Context->Rtl;
    Table = Context->Table;
    Keys = Table->Keys;
    File = *Item->FilePointer;
    ParentDirectory = File->ParentDirectory;
    Path = ParentDirectory->Path;
    Name = &Path->TableNameA;
    Upper = &Path->TableNameUpperA;
    TableInfoOnDisk = Table->TableInfoOnDisk;
    NumberOfSeeds = TableInfoOnDisk->NumberOfSeeds;
    IncludeKeys = (Table->TableCreateFlags.IncludeKeysInCompiledDll != FALSE);

    Base = (PCHAR)File->BaseAddress;
    Output = Base;

    //
    // Write the CMakeLists.txt file.
    //

    OUTPUT_RAW("# CMakeLists.txt: Auto-generated by Perfect Hash.\n");
    OUTPUT_RAW("# https://github.com/tpn/perfecthash\n");
    OUTPUT_RAW("#\n\n");
    OUTPUT_RAW("cmake_minimum_required(VERSION 3.10)\n\n");

    OUTPUT_RAW("project(");
    OUTPUT_STRING(Name);
    OUTPUT_RAW(")\n\n");

    OUTPUT_RAW("include_directories(..)\n");
    OUTPUT_RAW("include_directories(${CMAKE_CURRENT_SOURCE_DIR})\n\n");

    OUTPUT_RAW("if(MSVC)\n");
    OUTPUT_RAW("    foreach(var CMAKE_C_FLAGS_DEBUG CMAKE_CXX_FLAGS_DEBUG)\n");
    OUTPUT_RAW("        string(REPLACE \"/RTC1\" \"\" ${var} \"${${var}}\")\n");
    OUTPUT_RAW("        string(REPLACE \"/RTCc\" \"\" ${var} \"${${var}}\")\n");
    OUTPUT_RAW("        string(REPLACE \"/RTCs\" \"\" ${var} \"${${var}}\")\n");
    OUTPUT_RAW("        string(REPLACE \"/RTCu\" \"\" ${var} \"${${var}}\")\n");
    OUTPUT_RAW("        string(REPLACE \"/RTC\" \"\" ${var} \"${${var}}\")\n");
    OUTPUT_RAW("        string(REGEX REPLACE \"[ ]+\" \" \" ${var} \"${${var}}\")\n");
    OUTPUT_RAW("        set(${var} \"${${var}}\" CACHE STRING \"\" FORCE)\n");
    OUTPUT_RAW("    endforeach()\n");
    OUTPUT_RAW("    add_compile_options($<$<COMPILE_LANGUAGE:C,CXX>:/Oi>)\n");
    OUTPUT_RAW("endif()\n\n");

    OUTPUT_RAW("set(PCH_HEADER ");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("_StdAfx.h)\n");

    OUTPUT_RAW("set(PCH_SOURCE ");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("_StdAfx.c)\n\n");

    OUTPUT_RAW("add_library(");
    OUTPUT_STRING(Name);
    OUTPUT_RAW(" SHARED\n");

    //
    // Four-space indented filename with suffix.
    //

#define OUTPUT_FILE4(Suffix) \
    OUTPUT_RAW("    ");     \
    OUTPUT_STRING(Name);    \
    OUTPUT_RAW(Suffix);     \
    OUTPUT_RAW("\n");

    //
    // Eight-space indented filename with suffix.
    //

#define OUTPUT_FILE8(Suffix) \
    OUTPUT_RAW("        ");     \
    OUTPUT_STRING(Name);    \
    OUTPUT_RAW(Suffix);     \
    OUTPUT_RAW("\n");

    OUTPUT_FILE4(".c");
    OUTPUT_FILE4("_TableValues.c");
    OUTPUT_FILE4("_TableData.c");
    if (IncludeKeys) {
        OUTPUT_FILE4("_Keys.c");
    }
    OUTPUT_RAW("    ${PCH_SOURCE}\n");
    OUTPUT_RAW(")\n\n");

    OUTPUT_RAW("if(WIN32)\n");
    OUTPUT_RAW("    target_sources(");
    OUTPUT_STRING(Name);
    OUTPUT_RAW(" PRIVATE\n");
    OUTPUT_RAW("        ${PCH_HEADER}\n");
    OUTPUT_FILE8(".def");
    OUTPUT_RAW("    )\n");
    OUTPUT_RAW("endif()\n\n");

    //
    // Test executable.
    //

    OUTPUT_RAW("add_executable(Test_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n");
    OUTPUT_FILE4("_Support.c");
    OUTPUT_FILE4("_Keys.c");
    OUTPUT_FILE4("_Test.c");
    OUTPUT_FILE4("_TestExe.c");
    OUTPUT_RAW(")\n\n");
    OUTPUT_RAW("target_link_libraries(Test_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n    ");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n)\n\n");

    //
    // BenchmarkIndex executable.
    //

    OUTPUT_RAW("add_executable(BenchmarkIndex_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n");
    OUTPUT_FILE4("_Support.c");
    OUTPUT_FILE4("_Keys.c");
    OUTPUT_FILE4("_BenchmarkIndex.c");
    OUTPUT_FILE4("_BenchmarkIndexExe.c");
    OUTPUT_RAW(")\n\n");
    OUTPUT_RAW("target_link_libraries(BenchmarkIndex_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n    ");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n)\n\n");

    //
    // BenchmarkFull executable.
    //

    OUTPUT_RAW("add_executable(BenchmarkFull_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n");
    OUTPUT_FILE4("_Support.c");
    OUTPUT_FILE4("_Keys.c");
    OUTPUT_FILE4("_BenchmarkFull.c");
    OUTPUT_FILE4("_BenchmarkFullExe.c");
    OUTPUT_RAW(")\n\n");
    OUTPUT_RAW("target_link_libraries(BenchmarkFull_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n    ");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n)\n\n");

    //
    // C++ unity build.
    //

    OUTPUT_RAW("add_executable(Unity_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n");
    OUTPUT_FILE4(".cpp");
    OUTPUT_RAW(")\n\n");

    //
    // C++23 header-only implementation and test.
    //

    OUTPUT_RAW("add_library(");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("_CppHeaderOnly INTERFACE)\n");
    OUTPUT_RAW("target_include_directories(");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("_CppHeaderOnly INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})\n");
    OUTPUT_RAW("target_compile_features(");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("_CppHeaderOnly INTERFACE cxx_std_23)\n\n");

    OUTPUT_RAW("add_executable(CppHeaderOnlyTest_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n");
    OUTPUT_FILE4("_CppHeaderOnlyTest.cpp");
    OUTPUT_RAW(")\n\n");
    OUTPUT_RAW("target_link_libraries(CppHeaderOnlyTest_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n    ");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("_CppHeaderOnly\n)\n\n");
    OUTPUT_RAW("set_target_properties(CppHeaderOnlyTest_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW(" PROPERTIES CXX_STANDARD 23 CXX_STANDARD_REQUIRED YES)\n\n");

    //
    // CUDA kernel test executable.
    //

    OUTPUT_RAW("include(CheckLanguage)\n");
    OUTPUT_RAW("check_language(CUDA)\n");
    OUTPUT_RAW("if(CMAKE_CUDA_COMPILER)\n");
    OUTPUT_RAW("    enable_language(CUDA)\n");
    OUTPUT_RAW("    set(CMAKE_CUDA_STANDARD 17)\n");
    OUTPUT_RAW("    set(CMAKE_CUDA_STANDARD_REQUIRED ON)\n");
    OUTPUT_RAW("    if(MSVC)\n");
    OUTPUT_RAW("        string(REPLACE \"/RTC1\" \"\" CMAKE_CUDA_FLAGS_DEBUG \"${CMAKE_CUDA_FLAGS_DEBUG}\")\n");
    OUTPUT_RAW("        string(REPLACE \"/RTCc\" \"\" CMAKE_CUDA_FLAGS_DEBUG \"${CMAKE_CUDA_FLAGS_DEBUG}\")\n");
    OUTPUT_RAW("        string(REPLACE \"/RTCs\" \"\" CMAKE_CUDA_FLAGS_DEBUG \"${CMAKE_CUDA_FLAGS_DEBUG}\")\n");
    OUTPUT_RAW("        string(REPLACE \"/RTCu\" \"\" CMAKE_CUDA_FLAGS_DEBUG \"${CMAKE_CUDA_FLAGS_DEBUG}\")\n");
    OUTPUT_RAW("        string(REPLACE \"/RTC\" \"\" CMAKE_CUDA_FLAGS_DEBUG \"${CMAKE_CUDA_FLAGS_DEBUG}\")\n");
    OUTPUT_RAW("        string(REGEX REPLACE \"[ ]+\" \" \" CMAKE_CUDA_FLAGS_DEBUG \"${CMAKE_CUDA_FLAGS_DEBUG}\")\n");
    OUTPUT_RAW("        set(CMAKE_CUDA_FLAGS_DEBUG \"${CMAKE_CUDA_FLAGS_DEBUG}\" CACHE STRING \"\" FORCE)\n");
    OUTPUT_RAW("    endif()\n");
    OUTPUT_RAW("    find_package(CUDAToolkit)\n");
    OUTPUT_RAW("    if(CUDAToolkit_FOUND)\n");
    OUTPUT_RAW("        add_executable(CudaTest_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n");
    OUTPUT_FILE4(".cu");
    OUTPUT_RAW("        )\n\n");
    OUTPUT_RAW("        target_link_libraries(CudaTest_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW(" PRIVATE CUDA::cudart)\n");
    OUTPUT_RAW("        set_target_properties(CudaTest_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW(" PROPERTIES CUDA_STANDARD 17 CUDA_STANDARD_REQUIRED YES)\n");
    OUTPUT_RAW("    endif()\n");
    OUTPUT_RAW("endif()\n\n");

    //
    // Rust cargo targets.
    //

    OUTPUT_RAW("find_program(CARGO_EXECUTABLE cargo)\n");
    OUTPUT_RAW("if(CARGO_EXECUTABLE)\n");

    OUTPUT_RAW("    add_custom_target(RustTest_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n");
    OUTPUT_RAW("        COMMAND ${CARGO_EXECUTABLE} run --quiet --bin rust_test\n");
    OUTPUT_RAW("        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n");
    OUTPUT_RAW("    )\n");

    OUTPUT_RAW("    add_custom_target(RustBench_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n");
    OUTPUT_RAW("        COMMAND ${CARGO_EXECUTABLE} run --quiet --bin rust_bench --release\n");
    OUTPUT_RAW("        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n");
    OUTPUT_RAW("    )\n");

    OUTPUT_RAW("endif()\n\n");

    //
    // We're done, update number of bytes written and finish up.
    //

    File->NumberOfBytesWritten.QuadPart = RtlPointerToOffset(Base, Output);

    return S_OK;
}

// vim:set ts=8 sw=4 sts=4 tw=80 expandtab                                     :
