/*++

Copyright (c) 2025 Trent Nelson <trent@trent.me>

Module Name:

    Chm01FileWorkCudaSourceFile.c

Abstract:

    This module implements the save file work callback routine for the CUDA
    source file as part of the CHM v1 algorithm implementation for the
    perfect hash library.

--*/

#include "stdafx.h"

_Use_decl_annotations_
HRESULT
SaveCudaSourceFileChm01(
    PPERFECT_HASH_CONTEXT Context,
    PFILE_WORK_ITEM Item
    )
{
    PRTL Rtl;
    PCHAR Base;
    PCHAR Output;
    ULONG Count;
    PULONG Long;
    ULONGLONG Index;
    PCSTRING Name;
    PULONG Seeds;
    ULONG Seed1;
    ULONG Seed2;
    ULONG Seed3;
    ULONG Seed4;
    ULONG Seed5;
    ULONG Seed3Byte1;
    ULONG Seed3Byte2;
    ULONG Seed3Byte3;
    ULONG Seed3Byte4;
    PGRAPH Graph;
    PULONG Source;
    PUSHORT Source16;
    ULONGLONG NumberOfKeys;
    ULONG NumberOfSeeds;
    BOOLEAN UsingAssigned16;
    BOOLEAN Supported;
    HRESULT Result = S_OK;
    PPERFECT_HASH_KEYS Keys;
    PPERFECT_HASH_PATH Path;
    PPERFECT_HASH_FILE File;
    PPERFECT_HASH_TABLE Table;
    PTABLE_INFO_ON_DISK TableInfo;
    ULONGLONG TotalNumberOfElements;
    const ULONG Indent = 0x20202020;

    //
    // Initialize aliases.
    //

    Rtl = Context->Rtl;
    Table = Context->Table;
    Keys = Table->Keys;
    File = *Item->FilePointer;
    Path = GetActivePath(File);
    Name = &Path->TableNameA;
    TableInfo = Table->TableInfoOnDisk;
    TotalNumberOfElements = TableInfo->NumberOfTableElements.QuadPart;
    Graph = (PGRAPH)Context->SolvedContext;
    NumberOfSeeds = Graph->NumberOfSeeds;
    Seeds = &Graph->FirstSeed;
    NumberOfKeys = Keys->NumberOfKeys.QuadPart;
    UsingAssigned16 = IsUsingAssigned16(Graph);
    Supported = (
        Table->MaskFunctionId == PerfectHashAndMaskFunctionId &&
        IsGoodPerfectHashHashFunctionId(Table->HashFunctionId)
    );

    Base = (PCHAR)File->BaseAddress;
    Output = Base;

    //
    // Write header and includes.
    //

    OUTPUT_RAW("// Auto-generated by Perfect Hash.\n");
    OUTPUT_RAW("#include <cuda_runtime.h>\n");
    OUTPUT_RAW("#include <cstdint>\n");
    OUTPUT_RAW("#include <cstddef>\n");
    OUTPUT_RAW("#include <cstdio>\n");
    OUTPUT_RAW("#include <vector>\n");
    OUTPUT_RAW("#include <cstdlib>\n\n");

    OUTPUT_RAW("namespace perfecthash::generated::");
    OUTPUT_STRING(Name);
    OUTPUT_RAW(" {\n\n");

    OUTPUT_RAW("inline constexpr std::uint32_t algorithm_id = ");
    OUTPUT_INT(Table->AlgorithmId);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t hash_function_id = ");
    OUTPUT_INT(Table->HashFunctionId);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t mask_function_id = ");
    OUTPUT_INT(Table->MaskFunctionId);
    OUTPUT_RAW("u;\n\n");

    OUTPUT_RAW("inline constexpr std::uint32_t key_size_bytes = ");
    OUTPUT_INT(Keys->KeySizeInBytes);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t original_key_size_bytes = ");
    OUTPUT_INT(Keys->OriginalKeySizeInBytes);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::size_t number_of_keys = ");
    OUTPUT_INT((ULONG)NumberOfKeys);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("inline constexpr std::size_t number_of_table_elements = ");
    OUTPUT_INT((ULONG)TotalNumberOfElements);
    OUTPUT_RAW(";\n\n");

    OUTPUT_RAW("inline constexpr std::uint32_t hash_mask = ");
    OUTPUT_HEX(TableInfo->HashMask);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t index_mask = ");
    OUTPUT_HEX(TableInfo->IndexMask);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint64_t downsize_bitmap = ");
    if (KeysWereDownsized(Keys)) {
        OUTPUT_HEX64(Keys->DownsizeBitmap);
        OUTPUT_RAW("ULL");
    } else {
        OUTPUT_RAW("0ULL");
    }
    OUTPUT_RAW(";\n\n");

    if (Keys->KeySizeInBytes <= 4) {
        OUTPUT_RAW("using key_type = std::uint32_t;\n");
    } else {
        OUTPUT_RAW("using key_type = std::uint64_t;\n");
    }

    if (Keys->OriginalKeySizeInBytes <= 4) {
        OUTPUT_RAW("using original_key_type = std::uint32_t;\n");
    } else {
        OUTPUT_RAW("using original_key_type = std::uint64_t;\n");
    }

    if (UsingAssigned16) {
        OUTPUT_RAW("using table_data_type = std::uint16_t;\n\n");
    } else {
        OUTPUT_RAW("using table_data_type = std::uint32_t;\n\n");
    }

    OUTPUT_RAW("inline constexpr std::uint32_t key_bits = "
               "key_size_bytes * 8u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t original_key_bits = "
               "original_key_size_bytes * 8u;\n");
    OUTPUT_RAW("constexpr std::uint64_t mask_from_bits("
               "std::uint32_t bits) noexcept {\n");
    OUTPUT_RAW("    return (bits >= 64u) ? ~0ULL : ((1ULL << bits) - 1ULL);\n");
    OUTPUT_RAW("}\n");
    OUTPUT_RAW("inline constexpr std::uint64_t key_mask = "
               "mask_from_bits(key_bits);\n");
    OUTPUT_RAW("inline constexpr std::uint64_t original_key_mask = "
               "mask_from_bits(original_key_bits);\n\n");

    OUTPUT_RAW("inline constexpr bool kSupported = ");
    if (Supported) {
        OUTPUT_RAW("true");
    } else {
        OUTPUT_RAW("false");
    }
    OUTPUT_RAW(";\n\n");

    //
    // Write seed data.
    //

    OUTPUT_RAW("inline constexpr std::uint32_t number_of_seeds = ");
    OUTPUT_INT(NumberOfSeeds);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed1 = ");
    OUTPUT_HEX((NumberOfSeeds >= 1) ? Graph->Seeds[0] : 0);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed2 = ");
    OUTPUT_HEX((NumberOfSeeds >= 2) ? Graph->Seeds[1] : 0);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed3 = ");
    OUTPUT_HEX((NumberOfSeeds >= 3) ? Graph->Seeds[2] : 0);
    OUTPUT_RAW("u;\n\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed4 = ");
    OUTPUT_HEX((NumberOfSeeds >= 4) ? Graph->Seeds[3] : 0);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed5 = ");
    OUTPUT_HEX((NumberOfSeeds >= 5) ? Graph->Seeds[4] : 0);
    OUTPUT_RAW("u;\n\n");

    Seed1 = (NumberOfSeeds >= 1 ? Graph->Seeds[0] : 0);
    Seed2 = (NumberOfSeeds >= 2 ? Graph->Seeds[1] : 0);
    Seed3 = (NumberOfSeeds >= 3 ? Graph->Seeds[2] : 0);
    Seed4 = (NumberOfSeeds >= 4 ? Graph->Seeds[3] : 0);
    Seed5 = (NumberOfSeeds >= 5 ? Graph->Seeds[4] : 0);
    Seed3Byte1 = (Seed3 & 0xff);
    Seed3Byte2 = ((Seed3 >> 8) & 0xff);
    Seed3Byte3 = ((Seed3 >> 16) & 0xff);
    Seed3Byte4 = ((Seed3 >> 24) & 0xff);

    OUTPUT_RAW("inline constexpr std::uint32_t seed3_byte1 = ");
    OUTPUT_HEX(Seed3Byte1);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed3_byte2 = ");
    OUTPUT_HEX(Seed3Byte2);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed3_byte3 = ");
    OUTPUT_HEX(Seed3Byte3);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed3_byte4 = ");
    OUTPUT_HEX(Seed3Byte4);
    OUTPUT_RAW("u;\n\n");

    //
    // Write the table data array.
    //

    OUTPUT_RAW("static const table_data_type table_data[");
    OUTPUT_RAW("number_of_table_elements] = {\n");

    if (UsingAssigned16) {
        Source16 = Graph->Assigned16;

        for (Index = 0, Count = 0;
             Index < TotalNumberOfElements;
             Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX(*Source16++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }

    } else {
        Source = Graph->Assigned;

        for (Index = 0, Count = 0;
             Index < TotalNumberOfElements;
             Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX(*Source++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }
    }

    if (*(Output - 1) == ' ') {
        *(Output - 1) = '\n';
    }

    OUTPUT_RAW("};\n\n");

    //
    // Write the keys array.
    //

    OUTPUT_RAW("static const original_key_type keys[number_of_keys] = {\n");

    if (Keys->OriginalKeySizeType == LongType) {

        PULONG SourceKeys;

        SourceKeys = (PULONG)Keys->KeyArrayBaseAddress;

        for (Index = 0, Count = 0; Index < NumberOfKeys; Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX(*SourceKeys++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }

    } else if (Keys->OriginalKeySizeType == LongLongType) {

        PULONGLONG SourceKeys;

        SourceKeys = (PULONGLONG)Keys->File->BaseAddress;

        for (Index = 0, Count = 0; Index < NumberOfKeys; Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX64(*SourceKeys++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }

    } else {

        Result = PH_E_UNREACHABLE_CODE;
        PH_ERROR(SaveCudaSourceFileChm01_UnknownKeyType, Result);
        PH_RAISE(Result);
    }

    if (*(Output - 1) == ' ') {
        *(Output - 1) = '\n';
    }

    OUTPUT_RAW("};\n\n");

    //
    // Write helpers and kernels.
    //

    OUTPUT_RAW("__host__ __device__ __forceinline__ std::uint64_t "
               "extract_bits64(std::uint64_t value, "
               "std::uint64_t bitmap) noexcept {\n");
    OUTPUT_RAW("    std::uint64_t result = 0;\n");
    OUTPUT_RAW("    std::uint64_t out_bit = 0;\n");
    OUTPUT_RAW("    while (bitmap) {\n");
    OUTPUT_RAW("        const std::uint64_t lsb = bitmap & (~bitmap + 1);\n");
    OUTPUT_RAW("        if (value & lsb) {\n");
    OUTPUT_RAW("            result |= (1ULL << out_bit);\n");
    OUTPUT_RAW("        }\n");
    OUTPUT_RAW("        bitmap ^= lsb;\n");
    OUTPUT_RAW("        ++out_bit;\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    return result;\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("__host__ __device__ __forceinline__ key_type "
               "downsize_key(std::uint64_t key) noexcept {\n");
    OUTPUT_RAW("    key &= original_key_mask;\n");
    OUTPUT_RAW("    if (downsize_bitmap) {\n");
    OUTPUT_RAW("        return static_cast<key_type>(\n");
    OUTPUT_RAW("            extract_bits64(key, downsize_bitmap) & key_mask);\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    return static_cast<key_type>(key & key_mask);\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("__host__ __device__ __forceinline__ std::uint32_t "
               "rotr32(std::uint32_t value, std::uint32_t shift) noexcept {\n");
    OUTPUT_RAW("    shift &= 31u;\n");
    OUTPUT_RAW("    if (shift == 0u) {\n");
    OUTPUT_RAW("        return value;\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    return (value >> shift) | (value << (32u - shift));\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("__host__ __device__ __forceinline__ std::uint32_t "
               "index_from_key(original_key_type key, "
               "const table_data_type* table) noexcept {\n");
    OUTPUT_RAW("    if constexpr (kSupported) {\n");
    OUTPUT_RAW("        const key_type downsized = "
               "downsize_key(static_cast<std::uint64_t>(key));\n");
    if (Table->HashFunctionId == PerfectHashHashMultiplyShiftRFunctionId) {
        OUTPUT_RAW("        key_type vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed1));\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        key_type vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed2));\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte2;\n");
        OUTPUT_RAW("        const std::uint32_t masked_low = "
                   "static_cast<std::uint32_t>(vertex1 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t masked_high = "
                   "static_cast<std::uint32_t>(vertex2 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table[masked_low]);\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table[masked_high]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMultiplyShiftLRFunctionId) {
        OUTPUT_RAW("        key_type vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed1));\n");
        OUTPUT_RAW("        vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            vertex1 << seed3_byte1);\n");
        OUTPUT_RAW("        key_type vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed2));\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte2;\n");
        OUTPUT_RAW("        const std::uint32_t masked_low = "
                   "static_cast<std::uint32_t>(vertex1 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t masked_high = "
                   "static_cast<std::uint32_t>(vertex2 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table[masked_low]);\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table[masked_high]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMultiplyShiftRMultiplyFunctionId) {
        OUTPUT_RAW("        key_type vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed1));\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            vertex1 * static_cast<key_type>(seed2));\n");
        OUTPUT_RAW("        key_type vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed4));\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte2;\n");
        OUTPUT_RAW("        vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            vertex2 * static_cast<key_type>(seed5));\n");
        OUTPUT_RAW("        const std::uint32_t masked_low = "
                   "static_cast<std::uint32_t>(vertex1 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t masked_high = "
                   "static_cast<std::uint32_t>(vertex2 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table[masked_low]);\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table[masked_high]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMultiplyShiftR2FunctionId) {
        OUTPUT_RAW("        key_type vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed1));\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            vertex1 * static_cast<key_type>(seed2));\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte2;\n");
        OUTPUT_RAW("        key_type vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed4));\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte3;\n");
        OUTPUT_RAW("        vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            vertex2 * static_cast<key_type>(seed5));\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte4;\n");
        OUTPUT_RAW("        const std::uint32_t masked_low = "
                   "static_cast<std::uint32_t>(vertex1 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t masked_high = "
                   "static_cast<std::uint32_t>(vertex2 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table[masked_low]);\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table[masked_high]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMultiplyShiftRXFunctionId) {
        OUTPUT_RAW("        key_type vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed1));\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table["
                   "static_cast<std::uint32_t>(vertex1)]);\n");
        OUTPUT_RAW("        key_type vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed2));\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table["
                   "static_cast<std::uint32_t>(vertex2)]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMulshrolate1RXFunctionId) {
        OUTPUT_RAW("        const std::uint32_t downsized32 = "
                   "static_cast<std::uint32_t>(downsized);\n");
        OUTPUT_RAW("        std::uint32_t vertex1 = downsized32 * seed1;\n");
        OUTPUT_RAW("        vertex1 = rotr32(vertex1, seed3_byte2);\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table[vertex1]);\n");
        OUTPUT_RAW("        std::uint32_t vertex2 = downsized32 * seed2;\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table[vertex2]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMulshrolate2RXFunctionId) {
        OUTPUT_RAW("        const std::uint32_t downsized32 = "
                   "static_cast<std::uint32_t>(downsized);\n");
        OUTPUT_RAW("        std::uint32_t vertex1 = downsized32 * seed1;\n");
        OUTPUT_RAW("        vertex1 = rotr32(vertex1, seed3_byte2);\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table[vertex1]);\n");
        OUTPUT_RAW("        std::uint32_t vertex2 = downsized32 * seed2;\n");
        OUTPUT_RAW("        vertex2 = rotr32(vertex2, seed3_byte3);\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table[vertex2]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMulshrolate3RXFunctionId) {
        OUTPUT_RAW("        const std::uint32_t downsized32 = "
                   "static_cast<std::uint32_t>(downsized);\n");
        OUTPUT_RAW("        std::uint32_t vertex1 = downsized32 * seed1;\n");
        OUTPUT_RAW("        vertex1 = rotr32(vertex1, seed3_byte2);\n");
        OUTPUT_RAW("        vertex1 = vertex1 * seed4;\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table[vertex1]);\n");
        OUTPUT_RAW("        std::uint32_t vertex2 = downsized32 * seed2;\n");
        OUTPUT_RAW("        vertex2 = rotr32(vertex2, seed3_byte3);\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table[vertex2]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMulshrolate4RXFunctionId) {
        OUTPUT_RAW("        const std::uint32_t downsized32 = "
                   "static_cast<std::uint32_t>(downsized);\n");
        OUTPUT_RAW("        std::uint32_t vertex1 = downsized32 * seed1;\n");
        OUTPUT_RAW("        vertex1 = rotr32(vertex1, seed3_byte2);\n");
        OUTPUT_RAW("        vertex1 = vertex1 * seed4;\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table[vertex1]);\n");
        OUTPUT_RAW("        std::uint32_t vertex2 = downsized32 * seed2;\n");
        OUTPUT_RAW("        vertex2 = rotr32(vertex2, seed3_byte3);\n");
        OUTPUT_RAW("        vertex2 = vertex2 * seed5;\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table[vertex2]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else {
        OUTPUT_RAW("        (void)downsized;\n");
        OUTPUT_RAW("        return 0;\n");
    }
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    (void)key;\n");
    OUTPUT_RAW("    (void)table;\n");
    OUTPUT_RAW("    return 0;\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("__host__ __device__ __forceinline__ "
               "original_key_type lookup_key(original_key_type key, "
               "const table_data_type* table, "
               "const original_key_type* key_table) noexcept {\n");
    OUTPUT_RAW("    const std::uint32_t idx = index_from_key(key, table);\n");
    OUTPUT_RAW("    return key_table[idx];\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("__global__ void index_kernel("
               "const original_key_type* key_table, "
               "std::uint32_t* out, std::size_t count, "
               "const table_data_type* table) {\n");
    OUTPUT_RAW("    const std::size_t i = "
               "(blockIdx.x * blockDim.x) + threadIdx.x;\n");
    OUTPUT_RAW("    if (i < count) {\n");
    OUTPUT_RAW("        out[i] = index_from_key(key_table[i], table);\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("__global__ void lookup_kernel("
               "const original_key_type* query_keys, "
               "original_key_type* out, std::size_t count, "
               "const table_data_type* table, "
               "const original_key_type* key_table) {\n");
    OUTPUT_RAW("    const std::size_t i = "
               "(blockIdx.x * blockDim.x) + threadIdx.x;\n");
    OUTPUT_RAW("    if (i < count) {\n");
    OUTPUT_RAW("        out[i] = lookup_key(query_keys[i], table, key_table);\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("} // namespace perfecthash::generated::");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n\n");

    //
    // Host-side test entry point.
    //

    OUTPUT_RAW("namespace {\n\n");
    OUTPUT_RAW("inline void check_cuda(cudaError_t err, const char* what) {\n");
    OUTPUT_RAW("    if (err != cudaSuccess) {\n");
    OUTPUT_RAW("        std::fprintf(stderr, \"%s: %s\\n\", "
               "what, cudaGetErrorString(err));\n");
    OUTPUT_RAW("        std::exit(1);\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("}\n\n");
    OUTPUT_RAW("} // anonymous namespace\n\n");

    OUTPUT_RAW("int main() {\n");
    OUTPUT_RAW("    using namespace perfecthash::generated::");
    OUTPUT_STRING(Name);
    OUTPUT_RAW(";\n");
    OUTPUT_RAW("    if constexpr (!kSupported) {\n");
    OUTPUT_RAW("        std::printf(\"unsupported\\n\");\n");
    OUTPUT_RAW("        return 0;\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    if (number_of_keys == 0) {\n");
    OUTPUT_RAW("        std::printf(\"ok\\n\");\n");
    OUTPUT_RAW("        return 0;\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    original_key_type* d_keys = nullptr;\n");
    OUTPUT_RAW("    table_data_type* d_table = nullptr;\n");
    OUTPUT_RAW("    std::uint32_t* d_indices = nullptr;\n");
    OUTPUT_RAW("    original_key_type* d_lookup = nullptr;\n");
    OUTPUT_RAW("    const std::size_t keys_bytes = sizeof(keys);\n");
    OUTPUT_RAW("    const std::size_t table_bytes = sizeof(table_data);\n");
    OUTPUT_RAW("    const std::size_t index_bytes = "
               "sizeof(std::uint32_t) * number_of_keys;\n");
    OUTPUT_RAW("    const std::size_t lookup_bytes = "
               "sizeof(original_key_type) * number_of_keys;\n");
    OUTPUT_RAW("    check_cuda(cudaMalloc(&d_keys, keys_bytes), "
               "\"cudaMalloc keys\");\n");
    OUTPUT_RAW("    check_cuda(cudaMalloc(&d_table, table_bytes), "
               "\"cudaMalloc table\");\n");
    OUTPUT_RAW("    check_cuda(cudaMalloc(&d_indices, index_bytes), "
               "\"cudaMalloc indices\");\n");
    OUTPUT_RAW("    check_cuda(cudaMalloc(&d_lookup, lookup_bytes), "
               "\"cudaMalloc lookup\");\n");
    OUTPUT_RAW("    check_cuda(cudaMemcpy(d_keys, keys, keys_bytes, "
               "cudaMemcpyHostToDevice), \"cudaMemcpy keys\");\n");
    OUTPUT_RAW("    check_cuda(cudaMemcpy(d_table, table_data, table_bytes, "
               "cudaMemcpyHostToDevice), \"cudaMemcpy table\");\n");
    OUTPUT_RAW("    const std::size_t threads = 256;\n");
    OUTPUT_RAW("    const std::size_t blocks = "
               "(number_of_keys + threads - 1) / threads;\n");
    OUTPUT_RAW("    index_kernel<<<blocks, threads>>>(d_keys, d_indices, "
               "number_of_keys, d_table);\n");
    OUTPUT_RAW("    check_cuda(cudaGetLastError(), \"index_kernel\");\n");
    OUTPUT_RAW("    check_cuda(cudaDeviceSynchronize(), "
               "\"index_kernel sync\");\n");
    OUTPUT_RAW("    lookup_kernel<<<blocks, threads>>>(d_keys, d_lookup, "
               "number_of_keys, d_table, d_keys);\n");
    OUTPUT_RAW("    check_cuda(cudaGetLastError(), \"lookup_kernel\");\n");
    OUTPUT_RAW("    check_cuda(cudaDeviceSynchronize(), "
               "\"lookup_kernel sync\");\n");
    OUTPUT_RAW("    std::vector<std::uint32_t> indices(number_of_keys);\n");
    OUTPUT_RAW("    std::vector<original_key_type> looked_up(number_of_keys);\n");
    OUTPUT_RAW("    check_cuda(cudaMemcpy(indices.data(), d_indices, "
               "index_bytes, cudaMemcpyDeviceToHost), "
               "\"cudaMemcpy indices\");\n");
    OUTPUT_RAW("    check_cuda(cudaMemcpy(looked_up.data(), d_lookup, "
               "lookup_bytes, cudaMemcpyDeviceToHost), "
               "\"cudaMemcpy lookup\");\n");
    OUTPUT_RAW("    check_cuda(cudaFree(d_lookup), \"cudaFree lookup\");\n");
    OUTPUT_RAW("    check_cuda(cudaFree(d_indices), \"cudaFree indices\");\n");
    OUTPUT_RAW("    check_cuda(cudaFree(d_table), \"cudaFree table\");\n");
    OUTPUT_RAW("    check_cuda(cudaFree(d_keys), \"cudaFree keys\");\n");
    OUTPUT_RAW("    std::vector<std::uint8_t> seen("
               "static_cast<std::size_t>(index_mask) + 1u, 0);\n");
    OUTPUT_RAW("    for (std::size_t i = 0; i < number_of_keys; ++i) {\n");
    OUTPUT_RAW("        const std::uint32_t idx = indices[i];\n");
    OUTPUT_RAW("        if (idx > index_mask) {\n");
    OUTPUT_RAW("            std::fprintf(stderr, "
               "\"index out of range: %u\\n\", idx);\n");
    OUTPUT_RAW("            return 1;\n");
    OUTPUT_RAW("        }\n");
    OUTPUT_RAW("        if (seen[idx]) {\n");
    OUTPUT_RAW("            std::fprintf(stderr, "
               "\"collision at %u\\n\", idx);\n");
    OUTPUT_RAW("            return 1;\n");
    OUTPUT_RAW("        }\n");
    OUTPUT_RAW("        seen[idx] = 1;\n");
    OUTPUT_RAW("        const std::uint32_t host_idx = "
               "index_from_key(keys[i], table_data);\n");
    OUTPUT_RAW("        if (host_idx != idx) {\n");
    OUTPUT_RAW("            std::fprintf(stderr, "
               "\"mismatch: host %u vs gpu %u\\n\", host_idx, idx);\n");
    OUTPUT_RAW("            return 1;\n");
    OUTPUT_RAW("        }\n");
    OUTPUT_RAW("        if (looked_up[i] != keys[i]) {\n");
    OUTPUT_RAW("            std::fprintf(stderr, "
               "\"lookup mismatch at %zu\\n\", i);\n");
    OUTPUT_RAW("            return 1;\n");
    OUTPUT_RAW("        }\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    std::printf(\"ok\\n\");\n");
    OUTPUT_RAW("    return 0;\n");
    OUTPUT_RAW("}\n");

    //
    // Update the number of bytes written.
    //

    File->NumberOfBytesWritten.QuadPart = RtlPointerToOffset(Base, Output);

    return Result;
}

// vim:set ts=8 sw=4 sts=4 tw=80 expandtab                                     :
