/*++

Copyright (c) 2026 Trent Nelson <trent@trent.me>

Module Name:

    Chm01FileWorkCppHeaderOnlyFile.c

Abstract:

    This module implements the save file work callback routine for the C++23
    header-only file as part of the CHM v1 algorithm implementation for the
    perfect hash library.

--*/

#include "stdafx.h"

_Use_decl_annotations_
HRESULT
SaveCppHeaderOnlyFileChm01(
    PPERFECT_HASH_CONTEXT Context,
    PFILE_WORK_ITEM Item
    )
{
    PRTL Rtl;
    PCHAR Base;
    PCHAR Output;
    ULONG Count;
    PULONG Long;
    ULONGLONG Index;
    PCSTRING Name;
    PULONG Seeds;
    ULONG Seed1;
    ULONG Seed2;
    ULONG Seed3;
    ULONG Seed4;
    ULONG Seed5;
    ULONG Seed3Byte1;
    ULONG Seed3Byte2;
    ULONG Seed3Byte3;
    ULONG Seed3Byte4;
    PGRAPH Graph;
    PULONG Source;
    PUSHORT Source16;
    ULONGLONG NumberOfKeys;
    ULONG NumberOfSeeds;
    BOOLEAN UsingAssigned16;
    BOOLEAN Supported;
    HRESULT Result = S_OK;
    PPERFECT_HASH_KEYS Keys;
    PPERFECT_HASH_PATH Path;
    PPERFECT_HASH_FILE File;
    PPERFECT_HASH_TABLE Table;
    PTABLE_INFO_ON_DISK TableInfo;
    ULONGLONG TotalNumberOfElements;
    const ULONG Indent = 0x20202020;

    //
    // Initialize aliases.
    //

    Rtl = Context->Rtl;
    Table = Context->Table;
    Keys = Table->Keys;
    File = *Item->FilePointer;
    Path = GetActivePath(File);
    Name = &Path->TableNameA;
    TableInfo = Table->TableInfoOnDisk;
    TotalNumberOfElements = TableInfo->NumberOfTableElements.QuadPart;
    Graph = (PGRAPH)Context->SolvedContext;
    NumberOfSeeds = Graph->NumberOfSeeds;
    Seeds = &Graph->FirstSeed;
    NumberOfKeys = Keys->NumberOfKeys.QuadPart;
    UsingAssigned16 = IsUsingAssigned16(Graph);
    Supported = (
        Table->MaskFunctionId == PerfectHashAndMaskFunctionId &&
        IsGoodPerfectHashHashFunctionId(Table->HashFunctionId)
    );

    Base = (PCHAR)File->BaseAddress;
    Output = Base;

    //
    // Write header and includes.
    //

    OUTPUT_RAW("// Auto-generated by Perfect Hash.\n");
    OUTPUT_RAW("#pragma once\n\n");
    OUTPUT_RAW("#include <array>\n");
    OUTPUT_RAW("#include <cstdint>\n");
    OUTPUT_RAW("#include <cstddef>\n");
    OUTPUT_RAW("#include <stdexcept>\n\n");

    OUTPUT_RAW("namespace perfecthash::generated::");
    OUTPUT_STRING(Name);
    OUTPUT_RAW(" {\n\n");

    OUTPUT_RAW("inline constexpr std::uint32_t algorithm_id = ");
    OUTPUT_INT(Table->AlgorithmId);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t hash_function_id = ");
    OUTPUT_INT(Table->HashFunctionId);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t mask_function_id = ");
    OUTPUT_INT(Table->MaskFunctionId);
    OUTPUT_RAW("u;\n\n");

    OUTPUT_RAW("inline constexpr std::uint32_t key_size_bytes = ");
    OUTPUT_INT(Keys->KeySizeInBytes);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t original_key_size_bytes = ");
    OUTPUT_INT(Keys->OriginalKeySizeInBytes);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t number_of_keys = ");
    OUTPUT_INT((ULONG)NumberOfKeys);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t number_of_table_elements = ");
    OUTPUT_INT((ULONG)TotalNumberOfElements);
    OUTPUT_RAW("u;\n\n");

    OUTPUT_RAW("inline constexpr std::uint32_t hash_mask = ");
    OUTPUT_HEX(TableInfo->HashMask);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t index_mask = ");
    OUTPUT_HEX(TableInfo->IndexMask);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint64_t downsize_bitmap = ");
    if (KeysWereDownsized(Keys)) {
        OUTPUT_HEX64(Keys->DownsizeBitmap);
        OUTPUT_RAW("ULL");
    } else {
        OUTPUT_RAW("0ULL");
    }
    OUTPUT_RAW(";\n\n");

    if (Keys->KeySizeInBytes <= 4) {
        OUTPUT_RAW("using key_type = std::uint32_t;\n");
    } else {
        OUTPUT_RAW("using key_type = std::uint64_t;\n");
    }

    if (Keys->OriginalKeySizeInBytes <= 4) {
        OUTPUT_RAW("using original_key_type = std::uint32_t;\n\n");
    } else {
        OUTPUT_RAW("using original_key_type = std::uint64_t;\n\n");
    }

    OUTPUT_RAW("inline constexpr std::uint32_t key_bits = "
               "key_size_bytes * 8u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t original_key_bits = "
               "original_key_size_bytes * 8u;\n");
    OUTPUT_RAW("constexpr std::uint64_t mask_from_bits("
               "std::uint32_t bits) noexcept {\n");
    OUTPUT_RAW("    return (bits >= 64u) ? ~0ULL : ((1ULL << bits) - 1ULL);\n");
    OUTPUT_RAW("}\n");
    OUTPUT_RAW("inline constexpr std::uint64_t key_mask = "
               "mask_from_bits(key_bits);\n");
    OUTPUT_RAW("inline constexpr std::uint64_t original_key_mask = "
               "mask_from_bits(original_key_bits);\n\n");

    OUTPUT_RAW("inline constexpr bool kSupported = ");
    if (Supported) {
        OUTPUT_RAW("true");
    } else {
        OUTPUT_RAW("false");
    }
    OUTPUT_RAW(";\n\n");

    //
    // Write seed data.
    //

    OUTPUT_RAW("inline constexpr std::uint32_t number_of_seeds = ");
    OUTPUT_INT(NumberOfSeeds);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed1 = ");
    OUTPUT_HEX((NumberOfSeeds >= 1) ? Graph->Seeds[0] : 0);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed2 = ");
    OUTPUT_HEX((NumberOfSeeds >= 2) ? Graph->Seeds[1] : 0);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed3 = ");
    OUTPUT_HEX((NumberOfSeeds >= 3) ? Graph->Seeds[2] : 0);
    OUTPUT_RAW("u;\n\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed4 = ");
    OUTPUT_HEX((NumberOfSeeds >= 4) ? Graph->Seeds[3] : 0);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed5 = ");
    OUTPUT_HEX((NumberOfSeeds >= 5) ? Graph->Seeds[4] : 0);
    OUTPUT_RAW("u;\n\n");

    Seed1 = (NumberOfSeeds >= 1 ? Graph->Seeds[0] : 0);
    Seed2 = (NumberOfSeeds >= 2 ? Graph->Seeds[1] : 0);
    Seed3 = (NumberOfSeeds >= 3 ? Graph->Seeds[2] : 0);
    Seed4 = (NumberOfSeeds >= 4 ? Graph->Seeds[3] : 0);
    Seed5 = (NumberOfSeeds >= 5 ? Graph->Seeds[4] : 0);
    Seed3Byte1 = (Seed3 & 0xff);
    Seed3Byte2 = ((Seed3 >> 8) & 0xff);
    Seed3Byte3 = ((Seed3 >> 16) & 0xff);
    Seed3Byte4 = ((Seed3 >> 24) & 0xff);

    OUTPUT_RAW("inline constexpr std::uint32_t seed3_byte1 = ");
    OUTPUT_HEX(Seed3Byte1);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed3_byte2 = ");
    OUTPUT_HEX(Seed3Byte2);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed3_byte3 = ");
    OUTPUT_HEX(Seed3Byte3);
    OUTPUT_RAW("u;\n");
    OUTPUT_RAW("inline constexpr std::uint32_t seed3_byte4 = ");
    OUTPUT_HEX(Seed3Byte4);
    OUTPUT_RAW("u;\n\n");

    //
    // Write the table data array.
    //

    if (UsingAssigned16) {
        OUTPUT_RAW("using table_data_type = std::uint16_t;\n");
    } else {
        OUTPUT_RAW("using table_data_type = std::uint32_t;\n");
    }

    OUTPUT_RAW("inline constexpr std::array<table_data_type, "
               "number_of_table_elements> table_data = {\n");

    if (UsingAssigned16) {
        Source16 = Graph->Assigned16;

        for (Index = 0, Count = 0;
             Index < TotalNumberOfElements;
             Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX(*Source16++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }

    } else {
        Source = Graph->Assigned;

        for (Index = 0, Count = 0;
             Index < TotalNumberOfElements;
             Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX(*Source++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }
    }

    if (*(Output - 1) == ' ') {
        *(Output - 1) = '\n';
    }

    OUTPUT_RAW("};\n\n");

    //
    // Write the keys array.
    //

    OUTPUT_RAW("inline constexpr std::array<original_key_type, "
               "number_of_keys> keys = {\n");

    if (Keys->OriginalKeySizeType == LongType) {

        PULONG SourceKeys;

        SourceKeys = (PULONG)Keys->KeyArrayBaseAddress;

        for (Index = 0, Count = 0; Index < NumberOfKeys; Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX(*SourceKeys++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }

    } else if (Keys->OriginalKeySizeType == LongLongType) {

        PULONGLONG SourceKeys;

        SourceKeys = (PULONGLONG)Keys->File->BaseAddress;

        for (Index = 0, Count = 0; Index < NumberOfKeys; Index++) {

            if (Count == 0) {
                INDENT();
            }

            OUTPUT_HEX64(*SourceKeys++);

            *Output++ = ',';

            if (++Count == 4) {
                Count = 0;
                *Output++ = '\n';
            } else {
                *Output++ = ' ';
            }
        }

    } else {

        Result = PH_E_UNREACHABLE_CODE;
        PH_ERROR(SaveCppHeaderOnlyFileChm01_UnknownKeyType, Result);
        PH_RAISE(Result);
    }

    if (*(Output - 1) == ' ') {
        *(Output - 1) = '\n';
    }

    OUTPUT_RAW("};\n\n");

    //
    // Write helpers and index routine.
    //

    OUTPUT_RAW("constexpr std::uint64_t extract_bits64("
               "std::uint64_t value, std::uint64_t bitmap) noexcept {\n");
    OUTPUT_RAW("    std::uint64_t result = 0;\n");
    OUTPUT_RAW("    std::uint64_t out_bit = 0;\n");
    OUTPUT_RAW("    while (bitmap) {\n");
    OUTPUT_RAW("        const std::uint64_t lsb = bitmap & (~bitmap + 1);\n");
    OUTPUT_RAW("        if (value & lsb) {\n");
    OUTPUT_RAW("            result |= (1ULL << out_bit);\n");
    OUTPUT_RAW("        }\n");
    OUTPUT_RAW("        bitmap ^= lsb;\n");
    OUTPUT_RAW("        ++out_bit;\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    return result;\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("constexpr key_type downsize_key("
               "std::uint64_t key) noexcept {\n");
    OUTPUT_RAW("    key &= original_key_mask;\n");
    OUTPUT_RAW("    if (downsize_bitmap) {\n");
    OUTPUT_RAW("        return static_cast<key_type>(\n");
    OUTPUT_RAW("            extract_bits64(key, downsize_bitmap) & key_mask);\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    return static_cast<key_type>(key & key_mask);\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("constexpr std::uint32_t rotr32(std::uint32_t value, "
               "std::uint32_t shift) noexcept {\n");
    OUTPUT_RAW("    shift &= 31u;\n");
    OUTPUT_RAW("    if (shift == 0u) {\n");
    OUTPUT_RAW("        return value;\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    return (value >> shift) | (value << (32u - shift));\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("inline std::uint32_t index(original_key_type key) {\n");
    OUTPUT_RAW("    if constexpr (kSupported) {\n");
    OUTPUT_RAW("        const key_type downsized = downsize_key("
               "static_cast<std::uint64_t>(key));\n");
    if (Table->HashFunctionId == PerfectHashHashMultiplyShiftRFunctionId) {
        OUTPUT_RAW("        key_type vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed1));\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        key_type vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed2));\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte2;\n");
        OUTPUT_RAW("        const std::uint32_t masked_low = "
                   "static_cast<std::uint32_t>(vertex1 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t masked_high = "
                   "static_cast<std::uint32_t>(vertex2 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table_data[masked_low]);\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table_data[masked_high]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMultiplyShiftLRFunctionId) {
        OUTPUT_RAW("        key_type vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed1));\n");
        OUTPUT_RAW("        vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            vertex1 << seed3_byte1);\n");
        OUTPUT_RAW("        key_type vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed2));\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte2;\n");
        OUTPUT_RAW("        const std::uint32_t masked_low = "
                   "static_cast<std::uint32_t>(vertex1 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t masked_high = "
                   "static_cast<std::uint32_t>(vertex2 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table_data[masked_low]);\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table_data[masked_high]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMultiplyShiftRMultiplyFunctionId) {
        OUTPUT_RAW("        key_type vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed1));\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            vertex1 * static_cast<key_type>(seed2));\n");
        OUTPUT_RAW("        key_type vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed4));\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte2;\n");
        OUTPUT_RAW("        vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            vertex2 * static_cast<key_type>(seed5));\n");
        OUTPUT_RAW("        const std::uint32_t masked_low = "
                   "static_cast<std::uint32_t>(vertex1 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t masked_high = "
                   "static_cast<std::uint32_t>(vertex2 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table_data[masked_low]);\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table_data[masked_high]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMultiplyShiftR2FunctionId) {
        OUTPUT_RAW("        key_type vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed1));\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            vertex1 * static_cast<key_type>(seed2));\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte2;\n");
        OUTPUT_RAW("        key_type vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed4));\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte3;\n");
        OUTPUT_RAW("        vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            vertex2 * static_cast<key_type>(seed5));\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte4;\n");
        OUTPUT_RAW("        const std::uint32_t masked_low = "
                   "static_cast<std::uint32_t>(vertex1 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t masked_high = "
                   "static_cast<std::uint32_t>(vertex2 & hash_mask);\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table_data[masked_low]);\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table_data[masked_high]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMultiplyShiftRXFunctionId) {
        OUTPUT_RAW("        key_type vertex1 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed1));\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table_data["
                   "static_cast<std::size_t>(vertex1)]);\n");
        OUTPUT_RAW("        key_type vertex2 = static_cast<key_type>(\n");
        OUTPUT_RAW("            downsized * static_cast<key_type>(seed2));\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table_data["
                   "static_cast<std::size_t>(vertex2)]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMulshrolate1RXFunctionId) {
        OUTPUT_RAW("        const std::uint32_t downsized32 = "
                   "static_cast<std::uint32_t>(downsized);\n");
        OUTPUT_RAW("        std::uint32_t vertex1 = downsized32 * seed1;\n");
        OUTPUT_RAW("        vertex1 = rotr32(vertex1, seed3_byte2);\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table_data[vertex1]);\n");
        OUTPUT_RAW("        std::uint32_t vertex2 = downsized32 * seed2;\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table_data[vertex2]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMulshrolate2RXFunctionId) {
        OUTPUT_RAW("        const std::uint32_t downsized32 = "
                   "static_cast<std::uint32_t>(downsized);\n");
        OUTPUT_RAW("        std::uint32_t vertex1 = downsized32 * seed1;\n");
        OUTPUT_RAW("        vertex1 = rotr32(vertex1, seed3_byte2);\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table_data[vertex1]);\n");
        OUTPUT_RAW("        std::uint32_t vertex2 = downsized32 * seed2;\n");
        OUTPUT_RAW("        vertex2 = rotr32(vertex2, seed3_byte3);\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table_data[vertex2]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMulshrolate3RXFunctionId) {
        OUTPUT_RAW("        const std::uint32_t downsized32 = "
                   "static_cast<std::uint32_t>(downsized);\n");
        OUTPUT_RAW("        std::uint32_t vertex1 = downsized32 * seed1;\n");
        OUTPUT_RAW("        vertex1 = rotr32(vertex1, seed3_byte2);\n");
        OUTPUT_RAW("        vertex1 = vertex1 * seed4;\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table_data[vertex1]);\n");
        OUTPUT_RAW("        std::uint32_t vertex2 = downsized32 * seed2;\n");
        OUTPUT_RAW("        vertex2 = rotr32(vertex2, seed3_byte3);\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table_data[vertex2]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else if (Table->HashFunctionId ==
               PerfectHashHashMulshrolate4RXFunctionId) {
        OUTPUT_RAW("        const std::uint32_t downsized32 = "
                   "static_cast<std::uint32_t>(downsized);\n");
        OUTPUT_RAW("        std::uint32_t vertex1 = downsized32 * seed1;\n");
        OUTPUT_RAW("        vertex1 = rotr32(vertex1, seed3_byte2);\n");
        OUTPUT_RAW("        vertex1 = vertex1 * seed4;\n");
        OUTPUT_RAW("        vertex1 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_low = "
                   "static_cast<std::uint32_t>(table_data[vertex1]);\n");
        OUTPUT_RAW("        std::uint32_t vertex2 = downsized32 * seed2;\n");
        OUTPUT_RAW("        vertex2 = rotr32(vertex2, seed3_byte3);\n");
        OUTPUT_RAW("        vertex2 = vertex2 * seed5;\n");
        OUTPUT_RAW("        vertex2 >>= seed3_byte1;\n");
        OUTPUT_RAW("        const std::uint32_t value_high = "
                   "static_cast<std::uint32_t>(table_data[vertex2]);\n");
        OUTPUT_RAW("        return static_cast<std::uint32_t>("
                   "(value_low + value_high) & index_mask);\n");
    } else {
        OUTPUT_RAW("        (void)downsized;\n");
        OUTPUT_RAW("        throw std::logic_error("
                   "\"Unsupported hash/mask combination\");\n");
    }
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    (void)key;\n");
    OUTPUT_RAW("    throw std::logic_error("
               "\"Unsupported hash/mask combination\");\n");
    OUTPUT_RAW("}\n\n");

    OUTPUT_RAW("} // namespace perfecthash::generated::");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n");

    //
    // Update the number of bytes written.
    //

    File->NumberOfBytesWritten.QuadPart = RtlPointerToOffset(Base, Output);

    return Result;
}

// vim:set ts=8 sw=4 sts=4 tw=80 expandtab                                     :