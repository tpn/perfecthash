/*++

Copyright (c) 2025 Trent Nelson <trent@trent.me>

Module Name:

    Chm01FileWorkRustBenchFile.c

Abstract:

    This module implements the save file work callback routine for the Rust
    benchmark file as part of the CHM v1 algorithm implementation for the
    perfect hash library.

--*/

#include "stdafx.h"

_Use_decl_annotations_
HRESULT
SaveRustBenchFileChm01(
    PPERFECT_HASH_CONTEXT Context,
    PFILE_WORK_ITEM Item
    )
{
    PCHAR Base;
    PCHAR Output;
    PPERFECT_HASH_FILE File;

    //
    // Initialize aliases.
    //

    File = *Item->FilePointer;

    Base = (PCHAR)File->BaseAddress;
    Output = Base;

    //
    // Write benchmark file.
    //

    OUTPUT_RAW("// Auto-generated by Perfect Hash.\n");
    OUTPUT_RAW("use perfecthash_generated as ph;\n");
    OUTPUT_RAW("use std::hint::black_box;\n");
    OUTPUT_RAW("use std::time::Instant;\n\n");

    OUTPUT_RAW("fn main() {\n");
    OUTPUT_RAW("    if !ph::SUPPORTED {\n");
    OUTPUT_RAW("        println!(\"unsupported\");\n");
    OUTPUT_RAW("        return;\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    let iterations: usize = 100;\n");
    OUTPUT_RAW("    let mut acc: u64 = 0;\n");
    OUTPUT_RAW("    let start = Instant::now();\n");
    OUTPUT_RAW("    for _ in 0..iterations {\n");
    OUTPUT_RAW("        for &key in ph::KEYS.iter() {\n");
    OUTPUT_RAW("            acc = acc.wrapping_add(ph::index(key) as u64);\n");
    OUTPUT_RAW("        }\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("    black_box(acc);\n");
    OUTPUT_RAW("    let elapsed = start.elapsed();\n");
    OUTPUT_RAW("    let total = (iterations as u64) * (ph::NUMBER_OF_KEYS as u64);\n");
    OUTPUT_RAW("    println!(\"iterations: {}\", iterations);\n");
    OUTPUT_RAW("    println!(\"keys: {}\", ph::NUMBER_OF_KEYS);\n");
    OUTPUT_RAW("    println!(\"total lookups: {}\", total);\n");
    OUTPUT_RAW("    println!(\"elapsed: {:?}\", elapsed);\n");
    OUTPUT_RAW("    if total > 0 {\n");
    OUTPUT_RAW("        let nanos = elapsed.as_nanos() as f64;\n");
    OUTPUT_RAW("        let per_lookup = nanos / total as f64;\n");
    OUTPUT_RAW("        println!(\"ns/lookup: {:.2}\", per_lookup);\n");
    OUTPUT_RAW("    }\n");
    OUTPUT_RAW("}\n");

    //
    // Update the number of bytes written.
    //

    File->NumberOfBytesWritten.QuadPart = RtlPointerToOffset(Base, Output);

    return S_OK;
}

// vim:set ts=8 sw=4 sts=4 tw=80 expandtab                                     :
